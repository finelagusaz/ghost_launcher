# 開発プロセス改善分析と次アクション

作成日: 2026-02-25
前提: workspace/retrospective.md の洞察に基づく

---

## 現在の開発フロー（今回実績）

```
[1] 要件理解・調査    research.md
        ↓
[2] 実装計画          plan.md
        ↓
[3] 計画レビュー      plan.md 更新（13件修正）
        ↓
[4] 実装              PR-1〜6
        ↓
[5] コードレビュー    review.md（12件指摘）
        ↓
[6] 対応計画          feedback_plan.md
        ↓
[7] 修正実装          fix/15（Fix-A〜E）
        ↓
[8] CI 検証           ci_error.md → 修正
```

各ステップを以下で分析する。

---

## ステップごとの改善分析

### [1] 要件理解・調査

**今回できたこと**
- SPEC.md §15 の 7 タスクを読み解き、波及的影響を先に洗い出した
- 実施順序を依存関係に基づいて提案した（T-2+T-3 を同一 PR にまとめる等）

**見落とした視点**
- `cargo check` が CI に入っているにもかかわらず、「`cargo test` が実行されているか」を確認しなかった
- テスト基盤を追加するときに tsconfig.json との整合を検討しなかった

**改善: 調査時の追加確認項目**

```
□ CI ワークフロー（ci-build.yml）の現状を読み、各変更が CI で正しく検証されるか確認
□ テストファイルを追加する場合: tsconfig.json の include/exclude・vitest の include・CI の test ステップを確認
□ 新規依存関係を追加する場合: package.json・Cargo.toml の変更がコミット対象に漏れなく含まれるかを依存グラフで確認
```

---

### [2] 実装計画

**今回できたこと**
- 6 PR の依存グラフを可視化し、実施順序を明確にした
- 各 PR の変更対象ファイルと検証手順を記述した

**見落とした視点**
- テストケース一覧を計画に書いていなかった（→ 実装レビューで高-3 として指摘）
- CI ワークフローの変更を計画対象に含めていなかった（→ 中-3 として指摘）
- tsconfig.json の除外設定を計画に含めていなかった（→ CI エラーの遠因）

**改善: 計画書のセクション構成**

現行のセクション構成に「テスト計画」と「設定変更」を追加する。

```markdown
## PR-X: タイトル

### 変更対象ファイル
- ...

### テスト計画                          ← 追加
- 関数 foo: 正常系・ゼロ件・境界値（limit+1）
- 型ガード bar: 有効値・無効値・配列・null

### 設定変更（ある場合）                ← 追加
- CI ワークフロー: cargo check → cargo test
- tsconfig.json: exclude にテストパスを追加

### 検証手順
- ...
```

計画書にテストケースを書くことで、実装前に「どのテストが不足しているか」に気づける。

---

### [3] 計画レビュー

**今回できたこと**
- 13 件の問題を実装前に排除した（コミット単位の分割・依存関係の整理・実装漏れ等）

**見落とした視点**
- 「CI で実行されるか」という確認がなかった（cargo test が CI に入っていない問題）
- 「テスト設定の三者整合（CI・tsconfig・vitest）」という観点がなかった

**改善: 計画レビューの確認軸**

```
□ 機能的整合（何を作るか・依存関係・実施順序）   ← 今回できていた
□ テスト計画の完全性（何をテストするか・境界値）  ← 今回不足
□ CI 整合（変更が CI で実行・検証されるか）        ← 今回不足
□ 設定整合（tsconfig/vitest/Cargo.toml の更新漏れ）← 今回不足
```

---

### [4] 実装

**今回できたこと**
- KISS/DRY/SRP/YAGNI の方針を概ね遵守した
- テストを先に書き、それを満たす実装を書く順序を維持した

**致命的な失敗**
- PR-1〜6 の実装が完了したあと、コミットせずにセッションを終了した
- 次セッションで fix/15 を「PR-1〜6 が入っていない main」から作成し、ブランチの依存関係を破綻させた

**改善: 実装完了の定義を変更する**

「実装完了」を「コードが動く」ではなく「コミット済みかつ CI が通る状態」と定義する。

セッション終了前の必須手順:
```bash
git status        # working tree clean であることを確認
git log --oneline # コミット内容を確認
npm test          # テスト通過確認
```

`working tree clean` でないまま終了しない。次のセッションや次のブランチ作成の前に必ず確認する。

---

### [5] コードレビュー

**今回できたこと**
- 致命的・高・中・低の優先度で 12 件を整理した
- 対応しないものの理由を明記した（CLAUDE.md 方針との照合）

**見落とした視点**
- レビュー対象を「コード」としたが、「実装の状態（コミット済みか否か）」を確認しなかった
- `git log` を確認してから review を実施していれば、未コミット変更の存在に気づけた可能性がある

**改善: レビュー前の確認**

```bash
git log --oneline HEAD~5..HEAD   # 直近のコミット内容を確認
git status                        # 未コミット変更がないことを確認
```

「実装が完了しているか（コミット済みか）」はレビューの前提条件。未コミット変更がある状態でのレビューは、レビュー対象が不明確になるため行わない。

---

### [6] 対応計画（フィードバック計画）

**今回できたこと**
- Fix-A〜F の実施順序と影響分析を詳細に記述した
- 対応しない指摘の根拠を CLAUDE.md 方針と照合して明記した

**見落とした視点**
- 「fix/15 ブランチを作成する前提として PR-1〜6 が main にコミット済みであること」を計画の前提条件として記述しなかった
- ブランチ作成前の `git status` 確認を手順に含めなかった

**改善: 対応計画書にブランチ戦略を明記する**

```markdown
## 前提条件（ブランチ作成前に確認）
- [ ] git status が "nothing to commit, working tree clean" であること
- [ ] ベースブランチ（main）に前工程の変更が全て含まれていること
      `git log --oneline origin/main | head -5` で確認

## ブランチ戦略（GitHub Flow）
- ブランチ名: `{prefix}/{issue番号}-{英語で内容の説明}`
  - `feature/`  : 新機能の追加・開発   例: `feature/15-ghost-folder-sorting`
  - `bugfix/` または `fix/` : バグ修正 例: `fix/15-validation-cancel-error`
  - `hotfix/`   : 本番の緊急バグ修正   例: `hotfix/16-crash-on-launch`
  - `release/`  : リリース準備          例: `release/1.0.0`
  - `test/`     : テスト・実験的な作業  例: `test/15-vitest-setup`
  - `doc/` または `docs/` : ドキュメント更新 例: `docs/15-update-spec`
  - `refactor/` : リファクタリング・改善 例: `refactor/15-extract-token-helper`
  - 番号のみ（`fix/15`）は使わない
- 作成元: origin/main（clean state を確認後）
- PR マージ後はブランチを削除する
```

---

### [7] 修正実装

**今回できたこと**
- Fix-A〜E を明確な依存順序で実装した
- 各 Fix 後にテストで検証した

**見落とした視点**
- ブランチ作成時に前工程の変更が main に入っていないことに気づかなかった
- ローカルで `npm run build` が通ったのは「未コミット変更がローカルに存在したため」であり、CI との乖離を見落とした

**改善: ブランチ作成直後の確認**

```bash
# ブランチ作成直後に、期待するファイルがブランチに含まれているか確認
git show HEAD:src-tauri/Cargo.toml | grep sha2       # sha2 があるはず
git show HEAD:package.json | grep vitest              # vitest があるはず
git show HEAD:src/test/setup.ts 2>&1 | head -3        # setup があるはず
```

依存ファイルがコミットに含まれていることをブランチ直後に確認することで、「壊れたブランチ」を早期に検知できる。

---

### [8] CI 検証

**今回できたこと**
- エラーメッセージから根本原因を正確に特定した
- 対応方針（tsconfig.json の exclude 追加）が標準パターンであることを確認した

**見落とした視点**
- ローカルの `npm run build` がたまたま通っていたのは、未コミット変更が存在していたため。CI との状態差を意識していなかった
- CI エラーが出るまで「tsconfig.json の exclude が不足している」ことに気づかなかった

**改善: CI を壊さないための事前確認**

テスト基盤を新規追加した後、以下を確認する:

```bash
# CI 相当の状態（クリーンな checkout）をシミュレート
git stash                  # ローカル変更を退避（CI はコミット済みのみ見る）
npm run build              # CI の Build frontend と同じ
npm test                   # CI の Run frontend tests と同じ
cargo test --manifest-path src-tauri/Cargo.toml  # CI の Test Rust crate と同じ
git stash pop              # 退避を戻す
```

これにより「ローカルで通るが CI で落ちる」状態を事前に発見できる。

---

## 次にすべきこと

### 即時アクション（PR #16 の完了）

| 優先 | アクション | 根拠 |
|---|---|---|
| 1 | PR #16 の CI 結果を確認し、全ステップ通過を確認してマージ | tsconfig.json fix と PR-1〜6 追加コミットにより CI が通るはず |
| 2 | Fix-F（script-src 'unsafe-inline' の実機確認）を実施 | feedback_plan.md に記載の残タスク。コード変更なし |

### プロセス改善アクション（CLAUDE.md 更新）

retrospective.md の洞察を次の開発サイクルで活かすために、CLAUDE.md の「作業フロー」セクションを更新する。

**更新内容（案）:**

```markdown
## 作業フロー（改訂版）

1. **作業内容を明確にする** — 要件や目的を確認。CI ワークフローを読み、変更が CI で検証されるか確認する
2. **調査する** — 関連コードと影響範囲を調べる。テスト基盤（CI・tsconfig・vitest）との整合も確認する
3. **計画する** — 変更ファイル、テストケース一覧、設定変更を計画書に記述する
4. **テストを実装する** — 計画書のテストケースをコードとして先に書く
5. **テストがパスするように実装する** — 最小限のコードで実装する
6. **コミットする** — 実装完了 = コミット済み。`git status` が clean になるまでセッションを終了しない
7. **検証する** — `npm test`・`cargo test`・`npm run build` の全てが通ることを確認する
```

**追加: コミット前チェックリスト（CLAUDE.md に追記）:**

```markdown
## コミット前チェックリスト

- [ ] git status が "nothing to commit, working tree clean" になっている
- [ ] npm run build が通る
- [ ] npm test が通る（テストがある場合）
- [ ] cargo test が通る（Rust を変更した場合）
- [ ] 新規テストファイルを追加した場合:
      - CI ワークフローでそのテストが実行されるか
      - tsconfig.json の exclude に追加が必要か
      - vitest.config.ts の include が検出するか
```

### コードベース残課題

| 優先 | 課題 | 詳細 |
|---|---|---|
| 低 | Fix-F の完了記録 | `npm run tauri dev` で CSP エラーが出ないことを確認し、結果を記録する |
| 低 | ghostCacheRepository.test.ts の「10件以内では削除しない」テスト | 内部に `resetSettingsStore()` を2回呼ぶ冗長な実装になっている。テストをシンプルにリファクタリングできる |
| 参考 | ssp.exe チェックが3箇所になったタイミングで抽出 | CLAUDE.md 方針「3回目で抽出」に従い、ssp.rs の ssp.exe チェックが3箇所になれば `resolve_ssp_exe` ヘルパーに抽出する |

---

## 改善後の開発フロー（提案）

```
[1] 要件理解・調査
    + CI ワークフローの現状確認
    + テスト基盤との整合確認
        ↓
[2] 実装計画
    + テストケース一覧を計画書に記述
    + 設定変更（tsconfig/CI/vitest）を計画に含める
        ↓
[3] 計画レビュー（4軸で確認）
    機能整合・テスト計画・CI整合・設定整合
        ↓
[4] 実装
    + セッション終了前: git status clean を確認
        ↓
[5] コミット（実装完了の定義）
    git status clean + npm run build + npm test + cargo test
        ↓
[6] コードレビュー
    + レビュー前に git log と git status で実装状態を確認
        ↓
[7] 対応計画
    + ブランチ作成前提（git status clean）を計画書に明記
        ↓
[8] 修正実装（GitHub Flow）
    + ブランチ名: {prefix}/{issue番号}-{英語で内容の説明}
    + ブランチ作成直後に依存ファイルの存在確認
        ↓
[9] CI 検証
    + ローカルで CI 相当の検証（git stash でクリーン状態をシミュレート）
        ↓
[10] マージ
```

---

## 優先順位サマリー

```
今すぐ
  1. PR #16 CI 確認 → マージ
  2. Fix-F の実機確認（script-src 'unsafe-inline'）

今週中
  3. CLAUDE.md の作業フローに「コミット前チェックリスト」を追加

次の開発タスク開始時
  4. 改善後の開発フローを適用して実施
```
