# ソフトウェアエンジニアリング観点の振り返り

作成日: 2026-02-25（最終更新: 2026-02-25）
対象ドキュメント: workspace/{research, plan, review, feedback_plan, ci_error}.md、PR #16〜22 作業記録

---

## 概観

今回のサイクルは以下の順序で進んだ。

```
SPEC.md §15 解読
    ↓
research.md（波及影響調査）
    ↓
plan.md（実装計画 → レビューで 13 件修正）
    ↓
PR-1〜6 実装
    ↓
review.md（コードレビュー → 12 件の指摘）
    ↓
feedback_plan.md（フィードバック対応計画）
    ↓
Fix-A〜E 実装（fix/15 ブランチ）
    ↓
CI エラー（2件）
    ↓
ci_error.md → 修正
```

品質向上のサイクルが繰り返されるごとに問題が小さくなっていくという意味では健全な工程だった。一方で、各フェーズに共通する構造的な問題が確認された。

---

## 1. 未コミット変更の危険性 ── 最大の失敗

### 何が起きたか

PR-1〜6 の実装が完了したあと、変更がコミットされないままセッションが終了した。次のセッションで fix/15 ブランチが作成されたとき、ベースは「PR-1〜6 が入っていない main」だった。その fix/15 に Fix-A〜E（PR-1〜6 への修正）を積み重ねた結果、ブランチの状態は破綻した。

| コミット済み（fix/15）| ローカルのみ（未コミット）|
|---|---|
| fingerprint.rs（sha2 を使用）| Cargo.toml（sha2 エントリ）|
| SettingsPanel.tsx（validate_ssp_path を呼び出し）| ssp.rs（validate_ssp_path の定義）|
| ghostCacheRepository.test.ts（vitest を import）| package.json（vitest の依存関係）|
| ghostCacheRepository.test.ts（src/test/ を使用）| src/test/（モックと setup）|

コード単体は「正しく書けていた」が、コミット単位が依存関係を破壊していた。CI はこの状態を見て複数箇所で失敗するはずだった（実際には最初のビルドエラーで止まった）。

### 根本的な原因

「実装が完了した」という認識と「変更がバージョン管理に記録された」という事実が乖離していた。ローカルで `npm test` が通ることは「コードが正しい」ことを示すが、「リポジトリが正しい状態にある」ことは示さない。

### 洞察

> **「動くコードと管理されたコードは別物。セッションをまたぐ前に `git status` を確認し、作業単位でコミットする」**

fix/15 ブランチを切る前に `git status` が "nothing to commit, working tree clean" であることを確認していれば、この問題は防げた。ブランチ作成はコミット済み状態からのみ行うべきである。

---

## 2. テスト基盤の設定ミスが3層で重なった

review.md と ci_error.md には、テスト設定に関する独立した3つの問題が記録されている。

| # | 問題 | 影響 |
|---|---|---|
| 中-3 | CI が `cargo check` のみで `cargo test` を実行していない | Rust テスト6件が CI で検証されない |
| 低-4 | vitest.config.ts の `include` が `.tsx` を除外 | React コンポーネントテストが vitest に検出されない |
| CI エラー | tsconfig.json の `exclude` が未設定 | `tsc` がテストファイルを型チェックしてビルドを破壊 |

それぞれは独立した問題だが、共通の原因がある。**テスト基盤の設定が「後から追加された」ため、本体の設定（CI ワークフロー、tsconfig.json）との整合が取れていなかった。**

### 洞察

> **「テスト基盤は機能として設計する。追加のたびに、CI ・ tsconfig ・ vitest 設定の三者が整合しているか確認する」**

特に CI の `cargo check → cargo test` の問題は深刻だった。テストは存在するが実行されていない状態は、テストが存在しない状態より悪い可能性がある（「テストで保証されている」という誤った安心感を生む）。

テスト基盤導入時のチェックリストとして以下が有効：

```
□ CI で実行されているか（ワークフローファイルに明示されているか）
□ 型チェック対象から除外されているか（tsconfig.json の exclude）
□ テストランナーが正しいファイルを検出しているか（include パターン）
□ ローカルとCI で同じ結果が出るか（package-lock.json が同期されているか）
```

---

## 3. コードレビューが計画レビューより多くの問題を発見した

plan.md のレビューでは 13 件の問題が修正された。しかし実装後の review.md では新たに 12 件の指摘が上がった。

これは矛盾ではない。計画レビューは「何を作るか」の整合を確認するが、実装レビューは「どう作ったか」の品質を評価する。両者は見る角度が異なる。

ただし、いくつかの指摘は計画段階で発見できたはずのものだった。

| 指摘 | 計画で検討できたか |
|---|---|
| 高-2: missing/not-directory トークンの重複 | できた。plan.md に `push_entry_token` の設計が記載されているが、`push_absent_parent_token` の対称的な追加は検討されていなかった |
| 高-3: pruneOldEntries のテスト不足 | できた。PR-6 の計画に「何をテストするか」が記述されていれば事前に発見できた |
| 中-3: cargo check のみ | できた。CI 変更を PR に含める際に既存設定のレビューを行えばよかった |
| 低-1: 破壊的ソート | できた。`&mut Vec<String>` を選択した理由を計画に記述していれば、レビュー時に指摘を受けた可能性がある |

### 洞察

> **「計画書に "何をテストするか" を記述することで、テスト不足は実装前に発見できる」**

特に新規関数・新規モジュールを追加するとき、計画書の段階でテストケース一覧を書いておくと、実装後のカバレッジ不足を事前に防げる。

---

## 4. 重複排除のタイミング ── 「3回目で抽出」の正当性

CLAUDE.md の方針「2回まで許容、3回目で抽出」は、今回のケースで正しく機能した。

`missing`/`not-directory` トークン生成は fingerprint.rs と scan.rs の2箇所にあった。review.md は「高-2」として指摘し、feedback_plan.md で `push_absent_parent_token` として抽出された。

仮にこれが「2箇所でも即座に抽出」するポリシーだったとすれば、PR-2 の設計時点で `push_absent_parent_token` を追加していたはずで、review.md の指摘は発生しなかった。しかし `push_entry_token` を追加した PR-2 の時点では「missing/not-directory パスも共通化すべき」という認識が薄かった。

これは DRY 原則の実践における古典的なジレンマである。**「3回目で抽出」は、抽象化のコストと効果が釣り合うタイミングを待つという判断**であり、今回は review サイクルがその「3回目」のシグナルとして機能した。

### 洞察

> **「重複が2箇所のとき、"将来変更される可能性" を評価する。フォーマット文字列のような厳密な一致が要求されるケースは、2箇所でも共通化を検討すべきだった」**

`missing`/`not-directory` のトークン形式は fingerprint.rs と scan.rs が**同一の文字列フォーマットを使うことで意味を持つ**。これが崩れるとキャッシュが永続的に無効化されるバグになる（review.md 高-2 の指摘通り）。「意味的に一致しなければならないロジック」は2箇所でも共通化すべきであった。

---

## 5. 「不変性の表現」── Rust のシグネチャ設計

`compute_fingerprint_hash` の初期シグネチャは `&mut Vec<String>` だった。これは呼び出し後に `tokens` を使わないため実害はなかったが、「この関数は Vec を変更する」という誤ったコントラクトを暗示していた。

```rust
// 修正前: 破壊的ソートの副作用がある
pub(crate) fn compute_fingerprint_hash(tokens: &mut Vec<String>) -> String {
    tokens.sort();  // 呼び出し元の Vec を書き換える
    ...
}

// 修正後: 副作用なし
pub(crate) fn compute_fingerprint_hash(tokens: &[String]) -> String {
    let mut sorted = tokens.to_vec();  // 内部コピーをソート
    sorted.sort();
    ...
}
```

Rust の所有権システムはこの設計の問題を**型レベルで表現できる**。`&[String]` を受け取る関数は「スライスを読むだけで変更しない」という保証をシグネチャで示す。`&mut Vec<String>` は「変更する可能性がある」というコントラクトであり、変更しないなら使うべきでない。

### 洞察

> **「Rust では、"変更しない" という意図を型で表現できる。`&[T]` と `&mut Vec<T>` の使い分けはセマンティクスの問題。実際に変更しないなら `&[T]` を選ぶ」**

これは「低-1」に分類された指摘だが、将来の変更で混乱を生む可能性という意味では、影響度は分類より高い。シグネチャの意図明確化は、コードが正しく動く今のうちに行うべきである。

---

## 6. JavaScript の型ガード設計 ── `typeof [] === "object"` 問題

`isGhostCacheStoreV1` は `typeof candidate.entries === "object"` で判定していたが、JavaScript では配列も `"object"` を返す。`!Array.isArray(candidate.entries)` の追記が必要だった（低-3）。

これは JavaScript の型システムの既知の落とし穴であり、型ガード関数を書くときに毎回考慮すべき項目である。

### 洞察

> **「JavaScript の型ガードは最低限のチェックリストを持つ。特に `typeof` による object 判定では必ず `!Array.isArray` をペアで使う」**

TypeScript には型ガードを正しく書くためのテストパターンがある（ファジングに相当する境界値テスト）。今回の Fix-C で追加した `entries が配列の場合 false を返す` テストはその一例。型ガード関数には「通るべきでないものが通らないか」を確認するテストが必須である。

---

## 7. UI 状態の「クリーンアップ」設計

SettingsPanel の `validationError` は Dialog を閉じても保持され、次回開いたとき古いエラーが表示されたままになった（高-1）。

この問題の本質は、**「Dialog を閉じる」という操作が「フォームをリセットする」という意味を持つはずなのに、コードがその意図を実装していなかった**ことにある。

```typescript
// 修正前: キャンセルしてもエラーが残る
if (!selected) return;

// 修正後: キャンセル = フォームリセット
if (!selected) {
  setValidationError(null);
  return;
}
```

Fluent UI の Dialog は `open` prop で表示/非表示を制御するため、コンポーネントはアンマウントされない。React のステート管理では「DOM の非表示」と「ステートのリセット」は別の操作であることを常に意識する必要がある。

### 洞察

> **「コンポーネントが常にマウントされたまま表示/非表示を切り替える設計では、"閉じる" 操作でのステートリセットを明示的に実装する必要がある。アンマウントによる自動リセットに依存できない」**

---

## 8. テスト設計 ── private 関数のテスト戦略

`pruneOldEntries` はモジュール private（export されていない）。`writeGhostCacheEntry` を通じて間接的にテストする設計を取った。

```typescript
// pruneOldEntries を直接テストできない → writeGhostCacheEntry 経由でテスト
await writeGhostCacheEntry("key-new", newest);
const deleted = await readGhostCacheEntry("key-0");  // 削除されているはず
```

これは「実装の詳細ではなく振る舞いをテストする」という原則に沿った正しいアプローチである。一方で、テストデータの準備（10件のエントリを `cached_at` を変えながら用意）が複雑になった。

### 洞察

> **「private 関数のテストは、public API を通じた振る舞いのテストで代替する。ただし、そのために必要なテストデータ構築が複雑になる場合は、テストヘルパー（`makeEntry(cached_at)` 等）を用意してテストコードの読みやすさを保つ」**

---

## 9. 多段レビューサイクルの費用対効果

今回のサイクルを改めて見ると、レビューが2回行われた。

1. **計画レビュー（plan.md）**: 実装前に 13 件の問題を修正
2. **実装レビュー（review.md）**: 実装後に 12 件の問題を発見

計画レビューがなければ、13 件の問題を抱えたまま実装し、実装レビューでさらに 12 件が加わって合計 25 件の問題を修正する実装負荷が発生した可能性がある。実際には計画レビューが 13 件を事前に防ぎ、実装の品質を一定以上に保った。

ただし、計画→実装→レビュー→フィードバック計画→再実装→CI エラー→修正というサイクルは長く、**各フェーズのアウトプットドキュメントが「次のフェーズへの入力」として明確に機能した**ことが、このサイクルを回せた理由である。

### 洞察

> **「ドキュメントは "記録" ではなく "次の入力" として設計する。research.md は plan.md の入力であり、review.md は feedback_plan.md の入力である。この連鎖が明確に設計されていたことで、品質向上サイクルが機能した」**

---

---

## 10. 「症状を隠す修正」と「根本原因の修正」── Windows NTFS 遅延タイムスタンプ問題

### 何が起きたか

PR #19・#20 の GitHub Actions（Windows Server 2025）で `integrated_fingerprint_matches_standalone_build_fingerprint` テストが断続的に失敗した。

```
assertion `left == right` failed
  left:  "46a66ae6b286a8c0dea82452a44ef3d672672dcc8106e1ad081c4a1cf35d47f5"
 right:  "9182be201cb00f3e00cd7fc576eb0713dda39107ae94e0ed21120da445e2238b"
```

このテストは `build_fingerprint`（standalone）と `scan_ghosts_with_fingerprint_internal`（integrated）が同じフィンガープリントを返すことを確認するものだった。

**最初の仮説**: 2つの関数を連続呼び出しするタイミング問題 → ウォームアップ呼び出しを追加する修正を実施。

**結果**: 別のテスト `build_fingerprint_is_order_independent_for_additional_folders` が失敗し始めた。症状を移動させただけだった。

**根本原因の特定**:

| メタデータ取得方法 | Windows での実装 | 問題 |
|---|---|---|
| `entry.metadata()` | FindNextFile → WIN32_FIND_DATA → $FILE_NAME 属性 | NTFS 遅延タイムスタンプで陳腐化する |
| `fs::metadata(path)` | CreateFile + GetFileInformationByHandle → $STANDARD_INFORMATION 属性 | 常に最新値を返す |

NTFS は $FILE_NAME（親ディレクトリの $I30 B-tree に記録されるエントリの LastWriteTime）を遅延更新するが、$STANDARD_INFORMATION（ファイル自身に記録されるメタデータ）は同期的に更新する。`entry.metadata()` は前者を読み、`fs::metadata(path)` は後者を読む。

ディレクトリ作成直後に `read_dir` を2回呼び出すと、1回目と2回目の間に NTFS が $FILE_NAME を更新してしまい、`entry.metadata()` が返す `ftLastWriteTime` が変わっていた。

**実際の修正**: `fingerprint.rs` と `scan.rs` の `entry.metadata()` を `fs::metadata(entry.path())` に変更（PR #22）。

### ローカルで再現しなかった理由

macOS（HFS+/APFS）は遅延タイムスタンプ更新を行わない。`entry.metadata()` と `fs::metadata(path)` が返す値は常に一致する。

→ CI 環境（Windows）でのみ発生する問題を、ローカルで確認できなかった。

### 洞察

> **「最初に思いついた修正が "症状を隠しているだけ" である可能性を疑う。症状が別の場所に移動したならば、根本原因にたどり着いていない」**

ウォームアップ修正を push したとき、CI で「直前に失敗していたテストは通過し、別のテストが失敗した」という結果が返ってきた。これは根本原因を解決していないことを示す強いシグナルだった。

> **「プラットフォーム固有 API の挙動の差を意識する。`entry.metadata()` と `fs::metadata(path)` は同じデータを返すように見えて、Windows NTFS では異なるキャッシュレイヤーを参照する」**

特にファイルシステム関連のコードは、macOS・Linux・Windows で動作が異なる場合がある。「ローカルで通る = 正しい」という前提が崩れやすい領域である。

### 診断プロセスの振り返り

```
CI ログ確認
    ↓ 失敗テスト名と assert メッセージを読む
仮説立案（NTFS タイミング問題）
    ↓
最初の修正（ウォームアップ呼び出し）→ push → CI 確認
    ↓ 別のテストが失敗
仮説の再評価（症状の移動 = 根本原因未解決）
    ↓
$FILE_NAME vs $STANDARD_INFORMATION の違いを調査
    ↓
根本的な修正（entry.metadata() → fs::metadata()）→ push → CI 確認
    ↓ 全テスト通過
```

仮説→修正→CI確認 のサイクルを2回回した。1回目で根本原因にたどり着けなかったが、「症状が移動した」という CI の結果が根本原因への再分析を促した。

---

## 11. 開発プロセス改善の実践 ── next_action_plan.md A〜C の適用

### 何をしたか

next_action_plan.md（前サイクルの振り返りから生成した改善計画）のアクション A〜C を実際に実施した。

| アクション | 内容 | 結果 |
|---|---|---|
| A | PR #16 のマージ | ✅ CI 全通過後にマージ |
| B | CLAUDE.md 作業フロー改訂（7ステップ + コミット前チェックリスト） | ✅ PR #19 としてマージ |
| C | テストの冗長な二重初期化を削除（`ghostCacheRepository.test.ts`） | ✅ PR #20 としてマージ |

### 洞察

> **「プロセス改善は "記録" ではなく "実践" で完結する。振り返りドキュメントを書いた時点ではなく、次の開発サイクルで改善後のフローを実際に使ったときに、改善が機能したかどうかがわかる」**

CLAUDE.md に「コミット前チェックリスト」と「7ステップ作業フロー」を追加したことで、今サイクルではブランチ作成前の `git status` 確認が習慣化された。これは前サイクルの失敗（未コミット変更のまま fix/15 を切った）の直接的な改善である。

ただし B（CLAUDE.md 更新）を PR として提出した直後に C（テストリファクタリング）も実施し、両者が互いに依存のない別 PR として並行で CI を待つ状態が発生した。この「並行 PR の状態管理」については、一方が CI 失敗しているとき（#22 の修正が必要な間）、他方のマージも止まる可能性があることに留意が必要。

---

## まとめ：横断的に見えた3つの改善機会

### 改善機会 1: コミット規律

セッションをまたぐ前に `git status` が clean であることを確認する習慣を持つ。「実装完了 ≠ コミット済み」を明確に区別する。ブランチ作成は clean な状態からのみ行う。

### 改善機会 2: テスト基盤の整合確認

テストを追加するときは、「CI で実行されるか・tsconfig に除外されているか・テストランナーが検出するか」の3点を同時に確認する。テスト基盤の設定は後追いではなく、テスト追加と同時に完結させる。

### 改善機会 3: 計画書にテストケースを記述する

新規関数・モジュールを計画するとき、「何をテストするか」を計画書に明記する。これにより実装レビューで発見されるカバレッジ不足を事前に防げる。特に pruneOldEntries のような「limit を超えたとき」という境界条件は、計画段階でテストケースとして明示すべきだった。

### 改善機会 4: プラットフォーム固有挙動の事前確認

ファイルシステム・OS API を直接使うコードを追加するとき、「Windows でも同じ動作をするか」を明示的に確認する。特に以下は macOS と Windows で挙動が異なる既知のポイント：

| API | macOS | Windows |
|---|---|---|
| `entry.metadata()` | $STANDARD_INFORMATION と等価 | $FILE_NAME（FindNextFile キャッシュ）を参照、遅延更新あり |
| `fs::metadata(path)` | 同上 | $STANDARD_INFORMATION（GetFileInformationByHandle）を参照、常に最新 |
| `path.is_dir()` | `lstat` | `GetFileAttributes`、シンボリックリンクをたどる |

Windows CI（GitHub Actions Windows Server）は macOS ローカルでは発見できないバグの検知に有用だが、「断続的に失敗する」症状は原因特定を難しくする。「症状が移動するだけの修正」を見分けるには、2回目の CI 結果で「以前失敗していたテストが通り、別のテストが落ちる」パターンを見逃さないことが重要。
