# キャッシュDB仕様（10万レコード超対応版）

本章は、今後の DB 変更方針とキャッシュ運用を **10万レコード超** を前提に標準化するための仕様です。
対象は `ghosts.db` とし、`ghosts` は揮発キャッシュ、将来追加される `favorites` / `history` / `settings` は永続データとして明確に分離します。

## 1. 仕様の前提（SLO / 容量 / データ特性）

- 想定データ件数
  - 通常: 3万〜10万件
  - ピーク: 10万件超（運用上限は当面 20万件までを設計対象）
- 特性
  - `ghosts` は「ファイルシステムの索引」であり、再構築可能
  - 永続ユーザーデータは消失不可（お気に入り・履歴・設定）
- 最低限の運用目標（目安）
  - 一覧検索（`COUNT + SELECT LIMIT/OFFSET`）p95: 300ms 以内
  - 強制再読込（scan→保存）完了時間: 端末性能依存だが、劣化傾向を監視して回帰検知する

## 2. データモデル方針（Volatile / Persistent 分離）

### 2.1 Volatile（破壊可能）
- `ghosts` テーブル
- ルール
  - スキーマ変更時に `DELETE` / 再作成を許容
  - キャッシュ不整合時はフルスキャンで自己修復

### 2.2 Persistent（保持必須）
- 例: `favorites`, `launch_history`, `settings`, `usage_stats`
- ルール
  - マイグレーションで既存データを消さない
  - 破壊的変更時は移行 SQL を必須化

## 3. キー設計仕様（将来テーブル追加時の必須要件）

- **禁止**: `ghosts.id`（連番）を外部参照キーに使う
- **推奨**: 自然キーの複合化
  - 最低: `source + directory_name`
  - 文脈衝突を避ける必要がある場合: `normalized_ssp_path + source + directory_name`
- `favorites` 等の永続テーブルは、`ghosts` の再投入後も再結合できるキーで設計する

## 4. マイグレーション仕様

### 4.1 `ghosts` スキーマ変更時
- 必須手順
  1) 必要な `ALTER TABLE` / インデックス変更を実施
  2) `DELETE FROM ghosts;` を同 migration に含める
- 理由
  - 既存行の新規列未充足を残さないため
  - 次回起動時、`hasGhosts=false` を契機にフルスキャンで完全再投入させるため

### 4.2 Persistent スキーマ変更時
- 必須手順
  - 既存データ保持を前提に移行 SQL を実装
  - 互換性が崩れる場合は段階移行（新列追加→バックフィル→参照切替）

## 5. 寿命管理仕様（10万件超を見据えた標準）

### 5.1 保持ポリシー
- `request_key` 世代保持: 最新 5 世代
- TTL: 30 日
- 実際の削除条件: **世代超過 OR TTL超過**

### 5.2 実行タイミング
- 軽量クリーンアップ: `replaceGhostsByRequestKey` 成功直後
- 重量クリーンアップ（必要時）: 起動時 1 回
  - 条件例: DB サイズ閾値超過、削除累積量超過

### 5.3 物理サイズ管理
- 通常: `PRAGMA optimize`
- 容量逼迫時: `VACUUM` を非対話タイミングで実行
- `auto_vacuum` は書き込み頻度への影響を計測後に採用判断

## 6. 10万件超で顕在化するリスク

- 検索
  - `COUNT(*)` / `LIKE` / `OFFSET` の遅延増加
  - 旧世代残存により全体件数が膨張し、p95 が悪化
- 書き込み
  - `DELETE -> INSERT` の index 更新コスト増加
  - WAL 増大で保存完了遅延が体感化
- 安定性
  - 書き込み時間増加により待機競合が増え、失敗率が上がる可能性
- 容量
  - 削除のみではファイル縮小しないため、`VACUUM` 遅延時に容量圧迫

## 7. インデックス設計ガイド

- 維持
  - `request_key`
  - `request_key + name_lower`
  - `request_key + directory_name_lower`
- 寿命管理列（`updated_at` など）を導入する場合
  - 削除クエリの実行計画を確認して必要最小限で付与
- 注意
  - インデックス追加は読み取り改善と引き換えに書き込みコストを増やす

## 8. 監視・アラート仕様

### 8.1 収集項目（必須）
- `ghosts` 総件数
- `request_key` ごとの件数
- 検索 p95（`COUNT`, `SELECT ... LIMIT/OFFSET`）
- `ghosts.db` ファイルサイズ
- scan 完了から保存完了までの時間

### 8.2 推奨アラート閾値（初期値）
- 総件数 > 100,000
- DB サイズが運用基準値を継続超過
- 検索 p95 が 300ms を継続超過

## 9. 実装タスク（優先順位）

1. `ghosts` に `updated_at` を追加し、保持世代 + TTL クリーンアップを実装
2. 起動時の条件付きメンテナンス（`PRAGMA optimize` / 必要時 `VACUUM`）を追加
3. 永続テーブル追加時のキー仕様（`source + directory_name` 以上）を設計規約化
4. migration 追加時チェックリストに「`ghosts` 変更時の全消去」を明記
5. 監視項目をログ/メトリクスで可視化し、3万件時点から定点観測開始

## 10. 仕様変更時のレビュー観点

- この変更は Volatile / Persistent のどちらに属するか
- 再投入で壊れる参照（ID依存）がないか
- 10万件時の検索/保存/容量コストが悪化しないか
- クリーンアップとメンテナンスの自動実行条件が明確か
- 監視値で劣化を検知できるか
